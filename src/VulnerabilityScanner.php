<?php

namespace GeneroWP\WpCliWordfence;

use Exception;
use Generator;
use GeneroWP\WpCliWordfence\Models\Record;
use GeneroWP\WpCliWordfence\Models\Copyright;
use WP_CLI;

use function WP_CLI\Utils\get_flag_value;

/**
 * @see https://www.wordfence.com/intelligence-documentation/v2-accessing-and-consuming-the-vulnerability-data-feed/
 */
class VulnerabilityScanner
{
    const WORDFENCE_SCANNER_ENDPOINT = 'https://www.wordfence.com/api/intelligence/v2/vulnerabilities/scanner';
    const TRANSIENT_LAST_SCAN_TIME = '_wpcliwf-last-scan-time';

    protected bool $isForce = false;
    protected bool $isVerbose = false;

    /**
     * Scan active plugins for vulnerabilities
     *
     * [<Plugin>...]
     * : One or more plugin slugs to check
     *
     * [--force]
     * : Force run even if unchanged
     *
     * [--verbose]
     * : Use verbose output
     *
     * @param string[] $slugs
     * @param array<string,mixed> $flags
     */
    public function scan(array $slugs, array $flags): void
    {
        $this->isForce = (bool) get_flag_value($flags, 'force', false);
        $this->isVerbose = (bool) get_flag_value($flags, 'verbose', false);

        $args = [];
        $lastTimeRun = (int) get_transient(self::TRANSIENT_LAST_SCAN_TIME);
        if (! $this->isForce && $lastTimeRun) {
            $args['headers']['If-Modified-Since'] = gmdate('D, d M Y H:i:s', $lastTimeRun);
        }

        /** @var array<string,Copyright> copyrights */
        $copyrights = [];

        try {
            foreach ($this->getKnownVulnerabilities($args) as $record) {
                if ($slugs) {
                    $isMatch = array_reduce(
                        $slugs,
                        fn ($isMatch, $slug) => $isMatch || $record->isSoftware($slug),
                        false,
                    );
                    if (! $isMatch) {
                        continue;
                    }
                }

                try {
                    $this->validateVulnerable($record);
                } catch (VulnerabilityException $e) {
                    $refences = "\n\t" . implode("\n\t", $record->references);
                    WP_CLI::error(sprintf("[%s] %s %s", $e->getMessage(), $record->getMessage(), $refences), false);

                    /* @phpstan-ignore-next-line */
                    foreach ($record->copyrights as $copyright) {
                        if (!isset($copyrights[$copyright->slug])) {
                            $copyrights[$copyright->slug] = $copyright;
                        }
                    }
                }
            }

            foreach ($copyrights as $copyright) {
                WP_CLI::log(WP_CLI::colorize('%y' . $copyright->getNotice() . '%n'));
            }

            set_transient(self::TRANSIENT_LAST_SCAN_TIME, time());
        } catch (Exception $e) {
            WP_CLI::error(WP_CLI::error_to_string($e));
        }
    }

    /**
     * @throws VulnerabilityException
     */
    protected function validateVulnerable(Record $record): void
    {
        $plugins = $this->getPlugins();

        // @todo themes

        foreach ($record->software as $software) {
            $activeVersion = match ($software->type) {
                'core' => $this->getWpVersion(),
                'plugin' => $plugins[$software->slug] ?? null,
                default => null,
            };

            if (! $activeVersion) {
                $this->verbose('%s (%s): skipped not installed', $software->slug, $software->type);
                return;
            }

            if (! $software->patched) {
                $refences = "\n\t" . implode("\n\t", $record->references);
                WP_CLI::log(sprintf(
                    '%s %s %s',
                    WP_CLI::colorize('%yUnpatched vulnerability:%n'),
                    $record->title,
                    $refences,
                ));
                return;
            }

            foreach ($software->affectedVersions as $affectedVersion) {
                $fromOperator = $affectedVersion->fromInclusive ? '<' : '<=';
                $toOperator = $affectedVersion->toInclusive ? '>=' : '>';
                $fromVersion = $affectedVersion->fromVersion === '*' ? 0 : $affectedVersion->fromVersion;
                $toVersion = $affectedVersion->toVersion === '*' ? PHP_INT_MAX : $affectedVersion->toVersion;

                $isOlderThanVulnerableVersion = version_compare($activeVersion, $fromVersion, $fromOperator);
                if ($isOlderThanVulnerableVersion) {
                    continue;
                }

                $isNewerThanPatchedVersion = version_compare($activeVersion, $toVersion, $toOperator);
                if ($isNewerThanPatchedVersion) {
                    continue;
                }

                $message = sprintf('%s %s %s %s %s', $fromVersion, $fromOperator, $activeVersion, $toOperator, $toVersion);
                throw new VulnerabilityException($message);
            }
        }
    }

    /**
     * @return array<string,string> List of plugins with slug as key and version as value
     */
    protected static function getPlugins(): array
    {
        static $plugins = [];
        $plugins['imember360'] = '3.9.1';
        if (! $plugins) {
            foreach (get_plugins() as $filename => $data) {
                $slug = dirname($filename);
                $plugins[$slug] = $data['Version'];
            }
        }

        return $plugins;
    }

    protected static function getWpVersion(): string
    {
	    return str_replace('-src', '', $GLOBALS['wp_version']);
    }

    /**
     * @param array<string,mixed> $args
     * @return Generator|Record[]
     */
    protected function getKnownVulnerabilities(array $args = []): Generator
    {
        $result = $this->getResponse($args);
        if (is_null($result)) {
            WP_CLI::log('Unchanged');
            return;
        }
        foreach ($result as $data) {
            yield Record::fromRecord($data);
        }
    }

    /**
     * @param array<string,mixed> $args
     * @throws ApiException
     * @return null|array<string,mixed>
     */
    protected function getResponse(array $args = []): ?array
    {
        $response = wp_remote_get(
            self::WORDFENCE_SCANNER_ENDPOINT,
            array_merge([
                'headers' => [
                    'Accept' => 'application/json',
                ]
            ], $args),
        );

        if (is_wp_error($response)) {
            throw new ApiException($response->get_error_message());
        }

        $reponseCode = (int) wp_remote_retrieve_response_code($response);
        switch ($reponseCode) {
            case 200: // OK
                $result = json_decode(wp_remote_retrieve_body($response), true);

                if (json_last_error() !== JSON_ERROR_NONE) {
                    throw new ApiException(sprintf('JSON error: %s', json_last_error_msg()));
                }

                return $result;
            case 304: // Not modified
                return null;
            default:
                throw new ApiException(sprintf('Unknown response code: %s', $reponseCode));
        }
    }

    /**
     * @param mixed $args
     */
    protected function verbose(string $message, ...$args): void
    {
        if ($this->isVerbose) {
            WP_CLI::log(sprintf($message, ...$args));
        }
    }
}
